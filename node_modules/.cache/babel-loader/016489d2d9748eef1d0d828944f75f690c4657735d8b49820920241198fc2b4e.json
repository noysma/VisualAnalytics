{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport VueSlider from 'vue-slider-component';\nimport 'vue-slider-component/theme/default.css';\nimport { getSingleEndpoint } from \"../assets/apiConnector\";\nimport * as d3 from \"d3\";\nexport default {\n  components: {\n    VueSlider\n  },\n  data() {\n    return {\n      currentWeekIndex: 0,\n      totalWeeks: 0,\n      travelJournal: [],\n      weekLabels: [] // Array per le etichette delle settimane\n    };\n  },\n\n  computed: {\n    currentWeekLabel() {\n      // Calcola l'etichetta della settimana corrente\n      if (this.currentWeekIndex >= 0 && this.currentWeekIndex < this.weekLabels.length) {\n        return this.weekLabels[this.currentWeekIndex];\n      }\n      return \"\";\n    }\n  },\n  mounted() {\n    this.createChart();\n  },\n  methods: {\n    createChart() {\n      getSingleEndpoint({\n        participantId: 100\n      }, \"TravelJournal\").then(response => {\n        this.travelJournal = response.data.map(d => ({\n          type: \"Feature\",\n          properties: {\n            travelStartTime: d.travelStartTime,\n            travelStartLocationId: d.travelStartLocationId,\n            travelEndLocationId: d.travelEndLocationId,\n            checkInTime: d.checkInTime,\n            checkOutTime: d.checkOutTime,\n            endingBalance: d.endingBalance,\n            travelEndTime: d.travelEndTime,\n            participantId: d.participantId,\n            purpose: d.purpose,\n            startingBalance: d.startingBalance,\n            id: d.id\n          }\n        }));\n        const data = response.data;\n\n        // Parsing delle date e calcolo della durata dei viaggi in minuti\n        const parsedData = data.map(d => {\n          const startDate = new Date(d.travelStartTime);\n          const endDate = new Date(d.travelEndTime);\n          const travelTime = (endDate - startDate) / (1000 * 60); // Conversione da millisecondi a minuti\n          return {\n            startDate,\n            endDate,\n            travelTime\n          };\n        });\n\n        // Calcola il totale delle settimane\n        const weekStart = new Date(parsedData[0].startDate.getFullYear(), parsedData[0].startDate.getMonth(), parsedData[0].startDate.getDate() - parsedData[0].startDate.getDay());\n        const weekEnd = new Date(parsedData[parsedData.length - 1].startDate.getFullYear(), parsedData[parsedData.length - 1].startDate.getMonth(), parsedData[parsedData.length - 1].startDate.getDate() + 6);\n        const totalWeeks = Math.ceil((weekEnd - weekStart) / (1000 * 60 * 60 * 24 * 7));\n        this.totalWeeks = totalWeeks;\n\n        // Genera le etichette delle settimane\n        const weekLabels = [];\n        for (let i = 0; i < totalWeeks; i++) {\n          const currentWeekStart = new Date(weekStart.getFullYear(), weekStart.getMonth(), weekStart.getDate() + i * 7);\n          const currentWeekEnd = new Date(currentWeekStart.getFullYear(), currentWeekStart.getMonth(), currentWeekStart.getDate() + 6);\n          const label = `${currentWeekStart.toLocaleDateString()} - ${currentWeekEnd.toLocaleDateString()}`;\n          weekLabels.push(label);\n        }\n        this.weekLabels = weekLabels;\n\n        // Crea il grafico utilizzando D3\n        const margin = {\n          top: 20,\n          right: 20,\n          bottom: 30,\n          left: 40\n        };\n        const width = 800 - margin.left - margin.right;\n        const height = 400 - margin.top - margin.bottom;\n        const svg = d3.select(this.$refs.chartContainer).append(\"svg\").attr(\"width\", width + margin.left + margin.right).attr(\"height\", height + margin.top + margin.bottom);\n        const chart = svg.append(\"g\").attr(\"transform\", `translate(${margin.left},${margin.top})`);\n\n        // Funzione per aggiornare il grafico in base alla settimana selezionata\n        const updateChart = () => {\n          const currentWeekStart = new Date(weekStart.getFullYear(), weekStart.getMonth(), weekStart.getDate() + this.currentWeekIndex * 7);\n          const currentWeekEnd = new Date(currentWeekStart.getFullYear(), currentWeekStart.getMonth(), currentWeekStart.getDate() + 6);\n          const currentWeekData = parsedData.filter(d => {\n            return d.startDate >= currentWeekStart && d.startDate <= currentWeekEnd;\n          });\n\n          // Calcola il totale della differenza tra startDate e endDate per ogni giorno della settimana\n          const weekdays = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"];\n          const totalTravelTimes = weekdays.map(day => {\n            const dayTravelTimes = currentWeekData.filter(d => d.startDate.getDay() === weekdays.indexOf(day));\n            const totalTravelTime = d3.sum(dayTravelTimes, d => d.travelTime);\n            return {\n              day,\n              totalTravelTime\n            };\n          });\n\n          // Rimuovi il vecchio grafico\n          svg.selectAll(\".bar\").remove();\n          svg.selectAll(\".x-axis\").remove();\n          svg.selectAll(\".y-axis\").remove();\n\n          // Scala per gli assi x e y\n          const x = d3.scaleBand().domain(weekdays).range([0, width]).padding(0.1);\n          const yTicks = d3.range(0, d3.max(totalTravelTimes, d => d.totalTravelTime) + 600, 600); // Genera intervalli di 10 ore (600 minuti) per l'asse y\n          const y = d3.scaleLinear().domain([0, d3.max(totalTravelTimes, d => d.totalTravelTime) + 600]).range([height, 0]);\n\n          // Creazione degli assi x e y\n          const xAxis = d3.axisBottom(x);\n          const yAxis = d3.axisLeft(y).tickValues(yTicks).tickFormat(d => {\n            const hours = Math.floor(d / 60); // Calcola le ore\n            return `${hours}`; // Formatta l'etichetta come \"hh:00\"\n          });\n\n          // Aggiungi gli assi al grafico\n          chart.append(\"g\").attr(\"class\", \"x-axis\").attr(\"transform\", `translate(0, ${height})`).call(xAxis);\n          chart.append(\"g\").attr(\"class\", \"y-axis\").call(yAxis);\n\n          // Crea le barre del grafico\n          chart.selectAll(\".bar\").data(totalTravelTimes).enter().append(\"rect\").attr(\"class\", \"bar\").attr(\"x\", d => x(d.day)).attr(\"y\", d => y(d.totalTravelTime)).attr(\"width\", x.bandwidth()).attr(\"height\", d => height - y(d.totalTravelTime));\n        };\n\n        // Aggiorna il grafico iniziale\n        updateChart();\n\n        // Aggiorna il grafico quando viene cambiata la settimana selezionata\n        this.$watch(\"currentWeekIndex\", () => {\n          updateChart();\n        });\n      });\n    }\n  }\n};","map":{"version":3,"names":["VueSlider","getSingleEndpoint","d3","components","data","currentWeekIndex","totalWeeks","travelJournal","weekLabels","computed","currentWeekLabel","length","mounted","createChart","methods","participantId","then","response","map","d","type","properties","travelStartTime","travelStartLocationId","travelEndLocationId","checkInTime","checkOutTime","endingBalance","travelEndTime","purpose","startingBalance","id","parsedData","startDate","Date","endDate","travelTime","weekStart","getFullYear","getMonth","getDate","getDay","weekEnd","Math","ceil","i","currentWeekStart","currentWeekEnd","label","toLocaleDateString","push","margin","top","right","bottom","left","width","height","svg","select","$refs","chartContainer","append","attr","chart","updateChart","currentWeekData","filter","weekdays","totalTravelTimes","day","dayTravelTimes","indexOf","totalTravelTime","sum","selectAll","remove","x","scaleBand","domain","range","padding","yTicks","max","y","scaleLinear","xAxis","axisBottom","yAxis","axisLeft","tickValues","tickFormat","hours","floor","call","enter","bandwidth","$watch"],"sources":["src/components/Challenge3.vue"],"sourcesContent":["<!-- eslint-disable vue/multi-word-component-names -->\n<template>\n    <div>\n      <vue-slider v-model=\"currentWeekIndex\" :min=\"0\" :max=\"totalWeeks - 1\" :tooltip-format=\"weekLabels\" />\n      <div ref=\"chartContainer\"></div>\n      <p>Total Weeks: {{ totalWeeks }}</p>\n      <p>Current Week: {{ currentWeekLabel }}</p>\n    </div>\n  </template>\n  \n  <script>\n  import VueSlider from 'vue-slider-component';\n  import 'vue-slider-component/theme/default.css';\n  import { getSingleEndpoint } from \"../assets/apiConnector\";\n  import * as d3 from \"d3\";\n  \n  export default {\n    components: {\n      VueSlider,\n    },\n    data() {\n      return {\n        currentWeekIndex: 0,\n        totalWeeks: 0,\n        travelJournal: [],\n        weekLabels: [], // Array per le etichette delle settimane\n      };\n    },\n    computed: {\n      currentWeekLabel() {\n        // Calcola l'etichetta della settimana corrente\n        if (this.currentWeekIndex >= 0 && this.currentWeekIndex < this.weekLabels.length) {\n          return this.weekLabels[this.currentWeekIndex];\n        }\n        return \"\";\n      },\n    },\n    mounted() {\n      this.createChart();\n    },\n    methods: {\n      createChart() {\n        getSingleEndpoint({ participantId: 100 }, \"TravelJournal\").then((response) => {\n          this.travelJournal = response.data.map((d) => ({\n            type: \"Feature\",\n            properties: {\n              travelStartTime: d.travelStartTime,\n              travelStartLocationId: d.travelStartLocationId,\n              travelEndLocationId: d.travelEndLocationId,\n              checkInTime: d.checkInTime,\n              checkOutTime: d.checkOutTime,\n              endingBalance: d.endingBalance,\n              travelEndTime: d.travelEndTime,\n              participantId: d.participantId,\n              purpose: d.purpose,\n              startingBalance: d.startingBalance,\n              id: d.id,\n            },\n          }));\n          const data = response.data;\n  \n          // Parsing delle date e calcolo della durata dei viaggi in minuti\n          const parsedData = data.map((d) => {\n            const startDate = new Date(d.travelStartTime);\n            const endDate = new Date(d.travelEndTime);\n            const travelTime = (endDate - startDate) / (1000 * 60); // Conversione da millisecondi a minuti\n            return { startDate, endDate, travelTime };\n          });\n  \n          // Calcola il totale delle settimane\n          const weekStart = new Date(parsedData[0].startDate.getFullYear(), parsedData[0].startDate.getMonth(), parsedData[0].startDate.getDate() - parsedData[0].startDate.getDay());\n          const weekEnd = new Date(parsedData[parsedData.length - 1].startDate.getFullYear(), parsedData[parsedData.length - 1].startDate.getMonth(), parsedData[parsedData.length - 1].startDate.getDate() + 6);\n          const totalWeeks = Math.ceil((weekEnd - weekStart) / (1000 * 60 * 60 * 24 * 7));\n          this.totalWeeks = totalWeeks;\n  \n          // Genera le etichette delle settimane\n          const weekLabels = [];\n          for (let i = 0; i < totalWeeks; i++) {\n            const currentWeekStart = new Date(weekStart.getFullYear(), weekStart.getMonth(), weekStart.getDate() + (i * 7));\n            const currentWeekEnd = new Date(currentWeekStart.getFullYear(), currentWeekStart.getMonth(), currentWeekStart.getDate() + 6);\n            const label = `${currentWeekStart.toLocaleDateString()} - ${currentWeekEnd.toLocaleDateString()}`;\n            weekLabels.push(label);\n          }\n          this.weekLabels = weekLabels;\n  \n          // Crea il grafico utilizzando D3\n          const margin = { top: 20, right: 20, bottom: 30, left: 40 };\n          const width = 800 - margin.left - margin.right;\n          const height = 400 - margin.top - margin.bottom;\n  \n          const svg = d3\n            .select(this.$refs.chartContainer)\n            .append(\"svg\")\n            .attr(\"width\", width + margin.left + margin.right)\n            .attr(\"height\", height + margin.top + margin.bottom);\n  \n          const chart = svg.append(\"g\").attr(\"transform\", `translate(${margin.left},${margin.top})`);\n  \n          // Funzione per aggiornare il grafico in base alla settimana selezionata\n          const updateChart = () => {\n            const currentWeekStart = new Date(weekStart.getFullYear(), weekStart.getMonth(), weekStart.getDate() + (this.currentWeekIndex * 7));\n            const currentWeekEnd = new Date(currentWeekStart.getFullYear(), currentWeekStart.getMonth(), currentWeekStart.getDate() + 6);\n            const currentWeekData = parsedData.filter((d) => {\n              return d.startDate >= currentWeekStart && d.startDate <= currentWeekEnd;\n            });\n  \n            // Calcola il totale della differenza tra startDate e endDate per ogni giorno della settimana\n            const weekdays = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"];\n            const totalTravelTimes = weekdays.map((day) => {\n              const dayTravelTimes = currentWeekData.filter((d) => d.startDate.getDay() === weekdays.indexOf(day));\n              const totalTravelTime = d3.sum(dayTravelTimes, (d) => d.travelTime);\n              return { day, totalTravelTime };\n            });\n  \n            // Rimuovi il vecchio grafico\n            svg.selectAll(\".bar\").remove();\n            svg.selectAll(\".x-axis\").remove();\n            svg.selectAll(\".y-axis\").remove();\n  \n            // Scala per gli assi x e y\n            const x = d3.scaleBand().domain(weekdays).range([0, width]).padding(0.1);\n  \n            const yTicks = d3.range(0, d3.max(totalTravelTimes, (d) => d.totalTravelTime) + 600, 600); // Genera intervalli di 10 ore (600 minuti) per l'asse y\n            const y = d3\n              .scaleLinear()\n              .domain([0, d3.max(totalTravelTimes, (d) => d.totalTravelTime) + 600])\n              .range([height, 0]);\n  \n            // Creazione degli assi x e y\n            const xAxis = d3.axisBottom(x);\n            const yAxis = d3\n              .axisLeft(y)\n              .tickValues(yTicks)\n              .tickFormat((d) => {\n                const hours = Math.floor(d / 60); // Calcola le ore\n                return `${hours}`; // Formatta l'etichetta come \"hh:00\"\n              });\n  \n            // Aggiungi gli assi al grafico\n            chart.append(\"g\").attr(\"class\", \"x-axis\").attr(\"transform\", `translate(0, ${height})`).call(xAxis);\n  \n            chart.append(\"g\").attr(\"class\", \"y-axis\").call(yAxis);\n  \n            // Crea le barre del grafico\n            chart\n              .selectAll(\".bar\")\n              .data(totalTravelTimes)\n              .enter()\n              .append(\"rect\")\n              .attr(\"class\", \"bar\")\n              .attr(\"x\", (d) => x(d.day))\n              .attr(\"y\", (d) => y(d.totalTravelTime))\n              .attr(\"width\", x.bandwidth())\n              .attr(\"height\", (d) => height - y(d.totalTravelTime));\n          };\n  \n          // Aggiorna il grafico iniziale\n          updateChart();\n  \n          // Aggiorna il grafico quando viene cambiata la settimana selezionata\n          this.$watch(\"currentWeekIndex\", () => {\n            updateChart();\n          });\n        });\n      },\n    },\n  };\n  </script>\n  "],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}