{"ast":null,"code":"import { getSingleEndpoint } from \"@/assets/api_connector\";\nlet Buffer = require(\"buffer/\").Buffer;\nconst wkx = require(\"wkx\");\nconst d3 = require(\"d3\");\nimport { BuildingMap, BuildingTypeLegend } from \"@/assets/BuildingMap\";\nconst bm = new BuildingMap();\nconst bl = new BuildingTypeLegend();\nexport default {\n  name: \"App\",\n  components: {},\n  data() {\n    return {\n      buildings: [],\n      // Aggiungiamo uno stato per tenere traccia dei tipi di building mostrati sulla mappa\n      showTypes: {}\n    };\n  },\n  mounted() {\n    getSingleEndpoint({}, \"Buildings\").then(response => {\n      this.buildings = response.data.map(d => ({\n        type: \"Feature\",\n        geometry: wkx.Geometry.parse(Buffer.from(d.location, \"hex\")).toGeoJSON(),\n        properties: {\n          buildingId: d.buildingId,\n          buildingType: d.buildingType,\n          maxOccupancy: d.maxOccupancy,\n          units: d.units\n        }\n      }));\n      this.drawBuildings();\n    });\n  },\n  methods: {\n    drawBuildings() {\n      const selection = d3.select(this.$refs.map).select(\"g.buildings\");\n      const buildingTypes = d3.groups(this.buildings.map(d => d.properties.buildingType), d => d).map(d => d[0]);\n\n      // Inizializziamo lo stato di showTypes a true per tutti i tipi di building\n      buildingTypes.forEach(type => {\n        this.showTypes[type] = true;\n      });\n      console.log(\"buildingTypes\", buildingTypes);\n      bm.color().domain(buildingTypes);\n      const extent = {\n        type: \"GeometryCollection\",\n        geometries: this.buildings.map(d => d.geometry)\n      };\n      const projection = d3.geoIdentity().reflectY(true).fitSize([700, 700], extent);\n      const path = d3.geoPath().projection(projection);\n      selection.selectAll(\"path\").data(this.buildings).join(\"path\").attr(\"d\", path).attr(\"fill\", d => {\n        // Controlliamo se il tipo di building è mostrato sulla mappa\n        if (this.showTypes[d.properties.buildingType]) {\n          return bm.color()(d.properties.buildingType);\n        } else {\n          return \"transparent\";\n        }\n      }).attr(\"fill-opacity\", 0.2).attr(\"stroke\", \"grey\").on(\"mouseover\", function () {\n        d3.select(this).attr(\"fill-opacity\", 0.5);\n      }).on(\"mouseout\", function () {\n        d3.select(this).attr(\"fill-opacity\", 0.2);\n      });\n      bl.color(bm.color());\n      d3.select(this.$refs.map).select(\"g.legend\").call(bl);\n    },\n    // Aggiungiamo un metodo per ottenere il colore corrispondente al tipo di building\n    getColor(type) {\n      return bm.color()(type);\n    },\n    // Aggiungiamo un metodo per gestire il click sulla legenda\n    toggleShowType(type) {\n      // Invertiamo lo stato di showTypes per il tipo di building cliccato\n      this.showTypes[type] = !this.showTypes[type];\n\n      // Aggiorniamo la visualizzazione della mappa\n      const selection = d3.select(this.$refs.map).select(\"g.buildings\");\n      selection.selectAll(\"path\").attr(\"fill\", d => {\n        if (this.showTypes[d.properties.buildingType]) {\n          return bm.color()(d.properties.buildingType);\n        } else {\n          return \"transparent\";\n        }\n      });\n    }\n  }\n};","map":{"version":3,"names":["getSingleEndpoint","Buffer","require","wkx","d3","BuildingMap","BuildingTypeLegend","bm","bl","name","components","data","buildings","showTypes","mounted","then","response","map","d","type","geometry","Geometry","parse","from","location","toGeoJSON","properties","buildingId","buildingType","maxOccupancy","units","drawBuildings","methods","selection","select","$refs","buildingTypes","groups","forEach","console","log","color","domain","extent","geometries","projection","geoIdentity","reflectY","fitSize","path","geoPath","selectAll","join","attr","on","call","getColor","toggleShowType"],"sources":["src/App.vue"],"sourcesContent":["<template>\n  <b-container id=\"app\">\n    <b-row>\n      <b-col>\n        <div id=\"map\">\n            <svg width=\"100%\" height=\"700px\" ref=\"map\">\n                <g class=\"buildings\"></g>\n                <g class=\"legend\"></g>\n            </svg>\n        </div>\n        <div class=\"type-legend\">\n          <h4>Building Types</h4>\n          <div v-for=\"(showType, type) in showTypes\" :key=\"type\" class=\"type-legend-item\" @click=\"toggleShowType(type)\">\n            <div class=\"type-legend-color\" :style=\"{backgroundColor: getColor(type)}\"></div>\n            <div class=\"type-legend-label\">{{ type }}</div>\n          </div>\n        </div>\n      </b-col>\n    </b-row>\n  </b-container>\n</template>\n\n<script>\nimport { getSingleEndpoint } from \"@/assets/api_connector\";\nlet Buffer = require(\"buffer/\").Buffer;\nconst wkx = require(\"wkx\");\nconst d3 = require(\"d3\");\n\nimport { BuildingMap, BuildingTypeLegend } from \"@/assets/BuildingMap\";\n\nconst bm = new BuildingMap();\nconst bl = new BuildingTypeLegend();\n\nexport default {\n  name: \"App\",\n  components: {},\n  data() {\n    return {\n      buildings: [],\n      // Aggiungiamo uno stato per tenere traccia dei tipi di building mostrati sulla mappa\n      showTypes: {},\n    };\n  },\n  mounted() {\n    getSingleEndpoint({}, \"Buildings\").then((response) => {\n      this.buildings = response.data.map((d) => ({\n        type: \"Feature\",\n        geometry: wkx.Geometry.parse(Buffer.from(d.location, \"hex\")).toGeoJSON(),\n        properties: {\n          buildingId: d.buildingId,\n          buildingType: d.buildingType,\n          maxOccupancy: d.maxOccupancy,\n          units: d.units,\n        },\n      }));\n      this.drawBuildings();\n    });\n  },\n  methods: {\n    drawBuildings() {\n      const selection = d3.select(this.$refs.map).select(\"g.buildings\");\n\n      const buildingTypes = d3\n        .groups(this.buildings.map((d) => d.properties.buildingType), (d) => d)\n        .map((d) => d[0]);\n\n      // Inizializziamo lo stato di showTypes a true per tutti i tipi di building\n      buildingTypes.forEach((type) => {\n        this.showTypes[type] = true;\n      });\n\n      console.log(\"buildingTypes\", buildingTypes);\n      bm.color().domain(buildingTypes);\n\n      const extent = {\n        type: \"GeometryCollection\",\n        geometries: this.buildings.map((d) => d.geometry),\n      };\n\n      const projection = d3.geoIdentity()\n        .reflectY(true)\n        .fitSize([700, 700], extent);\n      const path = d3.geoPath().projection(projection);\n\n      selection.selectAll(\"path\")\n        .data(this.buildings)\n        .join(\"path\")\n        .attr(\"d\", path)\n        .attr(\"fill\", (d) => {\n          // Controlliamo se il tipo di building è mostrato sulla mappa\n          if (this.showTypes[d.properties.buildingType]) {\n            return bm.color()(d.properties.buildingType);\n          } else {\n            return \"transparent\";\n          }\n        })\n        .attr(\"fill-opacity\", 0.2)\n        .attr(\"stroke\", \"grey\")\n        .on(\"mouseover\", function () {\n          d3.select(this).attr(\"fill-opacity\", 0.5);\n        })\n        .on(\"mouseout\", function () {\n          d3.select(this).attr(\"fill-opacity\", 0.2);\n        });\n      \n      bl.color(bm.color());\n\n      d3.select(this.$refs.map).select(\"g.legend\")\n        .call(bl);\n\n    },\n    // Aggiungiamo un metodo per ottenere il colore corrispondente al tipo di building\n    getColor(type) {\n      return bm.color()(type);\n    },\n    // Aggiungiamo un metodo per gestire il click sulla legenda\n    toggleShowType(type) {\n// Invertiamo lo stato di showTypes per il tipo di building cliccato\n      this.showTypes[type] = !this.showTypes[type];\n\n      // Aggiorniamo la visualizzazione della mappa\n      const selection = d3.select(this.$refs.map).select(\"g.buildings\");\n\n      selection.selectAll(\"path\")\n        .attr(\"fill\", (d) => {\n          if (this.showTypes[d.properties.buildingType]) {\n            return bm.color()(d.properties.buildingType);\n          } else {\n            return \"transparent\";\n          }\n        });\n    },\n  },\n};\n</script>\n\n<style>\n#app {\n  font-family: Avenir, Helvetica, Arial, sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  color: #2c3e50;\n  margin-top: 60px;\n}\n\nsvg g.buildings path{\n    fill-opacity: 0.2;\n    stroke: grey;\n}\n\n.type-legend {\n  position: absolute;\n  top: 20px;\n  right: 20px;\n  background-color: white;\n  border-radius: 5px;\n  padding: 10px;\n  box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.2);\n}\n\n.type-legend h4 {\n  margin-top: 0;\n  margin-bottom: 10px;\n}\n\n.type-legend-item {\n  display: flex;\n  align-items: center;\n  cursor: pointer;\n  margin-bottom: 5px;\n}\n\n.type-legend-color {\n  width: 10px;\n  height: 10px;\n  margin-right: 5px;\n}\n\n.type-legend-label {\n  font-size: 12px;\n}\n</style>"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}