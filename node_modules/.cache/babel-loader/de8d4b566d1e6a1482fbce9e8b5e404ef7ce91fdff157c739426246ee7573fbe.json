{"ast":null,"code":"import VueSlider from 'vue-slider-component';\nimport 'vue-slider-component/theme/default.css';\nimport { getSingleEndpoint } from \"../assets/apiConnector\";\nimport * as d3 from \"d3\";\nexport default {\n  components: {\n    VueSlider\n  },\n  data() {\n    return {\n      currentWeekIndex: 0,\n      totalWeeks: 0,\n      travelJournal: [],\n      weekStart: null,\n      totalTravelTime: 0,\n      maxTravelTime: 0\n    };\n  },\n  mounted() {\n    this.createChart();\n  },\n  methods: {\n    createChart() {\n      getSingleEndpoint({\n        participantId: 1000\n      }, \"TravelJournal\").then(response => {\n        this.travelJournal = response.data.map(d => ({\n          type: \"Feature\",\n          properties: {\n            travelStartTime: d.travelStartTime,\n            travelStartLocationId: d.travelStartLocationId,\n            travelEndLocationId: d.travelEndLocationId,\n            checkInTime: d.checkInTime,\n            checkOutTime: d.checkOutTime,\n            endingBalance: d.endingBalance,\n            travelEndTime: d.travelEndTime,\n            participantId: d.participantId,\n            purpose: d.purpose,\n            startingBalance: d.startingBalance,\n            id: d.id\n          }\n        }));\n        const data = response.data;\n\n        // Parsing delle date e calcolo della durata dei viaggi in minuti\n        const parsedData = data.map(d => {\n          const startDate = new Date(d.travelStartTime);\n          const endDate = new Date(d.travelEndTime);\n          const travelTime = (endDate - startDate) / (1000 * 60); // Conversione da millisecondi a minuti\n          return {\n            startDate,\n            endDate,\n            travelTime\n          };\n        });\n\n        // Calcola il totale delle settimane\n        const weekStart = new Date(parsedData[0].startDate.getFullYear(), parsedData[0].startDate.getMonth(), parsedData[0].startDate.getDate() - parsedData[0].startDate.getDay());\n        const weekEnd = new Date(parsedData[parsedData.length - 1].startDate.getFullYear(), parsedData[parsedData.length - 1].startDate.getMonth(), parsedData[parsedData.length - 1].startDate.getDate() + 6);\n        const totalWeeks = Math.ceil((weekEnd - weekStart) / (1000 * 60 * 60 * 24 * 7));\n        this.totalWeeks = totalWeeks;\n        this.weekStart = weekStart;\n\n        // Crea il grafico utilizzando D3\n        const margin = {\n          top: 20,\n          right: 20,\n          bottom: 30,\n          left: 40\n        };\n        const width = 800 - margin.left - margin.right;\n        const height = 400 - margin.top - margin.bottom;\n        const svg = d3.select(this.$refs.chartContainer).append(\"svg\").attr(\"width\", width + margin.left + margin.right).attr(\"height\", height + margin.top + margin.bottom);\n        const chart = svg.append(\"g\").attr(\"transform\", `translate(${margin.left},${margin.top})`);\n\n        // Funzione per aggiornare il grafico in base alla settimana selezionata\n        const updateChart = () => {\n          const currentWeekStart = new Date(this.weekStart.getFullYear(), this.weekStart.getMonth(), this.weekStart.getDate() + this.currentWeekIndex * 7);\n          const currentWeekEnd = new Date(currentWeekStart.getFullYear(), currentWeekStart.getMonth(), currentWeekStart.getDate() + 6);\n          const currentWeekData = parsedData.filter(d => {\n            return d.startDate >= currentWeekStart && d.startDate <= currentWeekEnd;\n          });\n\n          // Calcola il totale della differenza tra startDate e endDate per ogni giorno della settimana\n          const weekdays = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"];\n          const totalTravelTime = parsedData.reduce((total, d) => total + d.travelTime, 0);\n          this.totalTravelTime = totalTravelTime;\n          const totalTravelTimes = weekdays.map(day => {\n            const dayTravelTimes = currentWeekData.filter(d => d.startDate.getDay() === weekdays.indexOf(day));\n            const totalTravelTime = d3.sum(dayTravelTimes, d => d.travelTime);\n            return {\n              day,\n              totalTravelTime\n            };\n          });\n\n          // Rimuovi il vecchio grafico\n          svg.selectAll(\".bar\").remove();\n          svg.selectAll(\".x-axis\").remove();\n          svg.selectAll(\".y-axis\").remove();\n\n          // Scala per gli assi x e y\n          const x = d3.scaleBand().domain(weekdays).range([0, width]).padding(0.1);\n          const yTicks = d3.range(0, this.maxTravelTime + 600, 600); // Utilizza this.maxTravelTime come valore massimo per l'asse y\n          const y = d3.scaleLinear().domain([0, this.maxTravelTime + 600]).range([height, 0]);\n\n          // Creazione degli assi x e y\n          const xAxis = d3.axisBottom(x);\n          const yAxis = d3.axisLeft(y).tickValues(yTicks).tickFormat(d => {\n            const hours = Math.floor(d / 60); // Calcola le ore\n            return `${hours}`; // Formatta l'etichetta come \"hh:00\"\n          });\n\n          // Aggiungi gli assi al grafico\n          chart.append(\"g\").attr(\"class\", \"x-axis\").attr(\"transform\", `translate(0, ${height})`).call(xAxis);\n          chart.append(\"g\").attr(\"class\", \"y-axis\").call(yAxis);\n\n          // Crea le barre del grafico\n          chart.selectAll(\".bar\").data(totalTravelTimes).enter().append(\"rect\").attr(\"class\", \"bar\").attr(\"x\", d => x(d.day)).attr(\"y\", d => y(d.totalTravelTime)).attr(\"width\", x.bandwidth()).attr(\"height\", d => height - y(d.totalTravelTime));\n        };\n\n        // Calcola il valore massimo della durata del viaggio su tutte le settimane\n        const maxTravelTime = d3.max(parsedData, d => d.travelTime);\n        this.maxTravelTime = maxTravelTime;\n\n        // Aggiorna il grafico iniziale\n        updateChart();\n\n        // Aggiorna il grafico quando viene cambiata la settimana selezionata\n        this.$watch(\"currentWeekIndex\", () => {\n          updateChart();\n        });\n      });\n    },\n    formatWeekLabel(value) {\n      const currentWeekStart = new Date(this.weekStart.getFullYear(), this.weekStart.getMonth(), this.weekStart.getDate() + value * 7);\n      const currentWeekEnd = new Date(currentWeekStart.getFullYear(), currentWeekStart.getMonth(), currentWeekStart.getDate() + 6);\n      const startDay = currentWeekStart.getDate();\n      const startMonth = new Intl.DateTimeFormat('en', {\n        month: 'long'\n      }).format(currentWeekStart);\n      const startYear = currentWeekStart.getFullYear();\n      const endDay = currentWeekEnd.getDate();\n      const endMonth = new Intl.DateTimeFormat('en', {\n        month: 'long'\n      }).format(currentWeekEnd);\n      const endYear = currentWeekEnd.getFullYear();\n      return `${startDay} ${startMonth} ${startYear} - ${endDay} ${endMonth} ${endYear}`;\n    }\n  }\n};","map":{"version":3,"names":["VueSlider","getSingleEndpoint","d3","components","data","currentWeekIndex","totalWeeks","travelJournal","weekStart","totalTravelTime","maxTravelTime","mounted","createChart","methods","participantId","then","response","map","d","type","properties","travelStartTime","travelStartLocationId","travelEndLocationId","checkInTime","checkOutTime","endingBalance","travelEndTime","purpose","startingBalance","id","parsedData","startDate","Date","endDate","travelTime","getFullYear","getMonth","getDate","getDay","weekEnd","length","Math","ceil","margin","top","right","bottom","left","width","height","svg","select","$refs","chartContainer","append","attr","chart","updateChart","currentWeekStart","currentWeekEnd","currentWeekData","filter","weekdays","reduce","total","totalTravelTimes","day","dayTravelTimes","indexOf","sum","selectAll","remove","x","scaleBand","domain","range","padding","yTicks","y","scaleLinear","xAxis","axisBottom","yAxis","axisLeft","tickValues","tickFormat","hours","floor","call","enter","bandwidth","max","$watch","formatWeekLabel","value","startDay","startMonth","Intl","DateTimeFormat","month","format","startYear","endDay","endMonth","endYear"],"sources":["src/components/Challenge3.vue"],"sourcesContent":["<!-- eslint-disable vue/multi-word-component-names -->\n<template>\n<div>\n    <vue-slider v-model=\"currentWeekIndex\" :min=\"0\" :max=\"totalWeeks - 1\" :tooltip-formatter=\"formatWeekLabel\" />\n    <div ref=\"chartContainer\"></div>\n</div>\n</template>\n  \n<script>\nimport VueSlider from 'vue-slider-component';\nimport 'vue-slider-component/theme/default.css';\nimport { getSingleEndpoint } from \"../assets/apiConnector\";\nimport * as d3 from \"d3\";\n\nexport default {\ncomponents: {\n    VueSlider,\n},\ndata() {\n    return {\n    currentWeekIndex: 0,\n    totalWeeks: 0,\n    travelJournal: [],\n    weekStart: null,\n    totalTravelTime: 0,\n    maxTravelTime: 0,\n    };\n},\nmounted() {\n    this.createChart();\n},\nmethods: {\n    createChart() {\n    getSingleEndpoint({ participantId: 1000 }, \"TravelJournal\").then((response) => {\n        this.travelJournal = response.data.map((d) => ({\n        type: \"Feature\",\n        properties: {\n            travelStartTime: d.travelStartTime,\n            travelStartLocationId: d.travelStartLocationId,\n            travelEndLocationId: d.travelEndLocationId,\n            checkInTime: d.checkInTime,\n            checkOutTime: d.checkOutTime,\n            endingBalance: d.endingBalance,\n            travelEndTime: d.travelEndTime,\n            participantId: d.participantId,\n            purpose: d.purpose,\n            startingBalance: d.startingBalance,\n            id: d.id,\n        },\n        }));\n        const data = response.data;\n\n        // Parsing delle date e calcolo della durata dei viaggi in minuti\n        const parsedData = data.map((d) => {\n        const startDate = new Date(d.travelStartTime);\n        const endDate = new Date(d.travelEndTime);\n        const travelTime = (endDate - startDate) / (1000 * 60); // Conversione da millisecondi a minuti\n        return { startDate, endDate, travelTime };\n        });\n\n        // Calcola il totale delle settimane\n        const weekStart = new Date(parsedData[0].startDate.getFullYear(), parsedData[0].startDate.getMonth(), parsedData[0].startDate.getDate() - parsedData[0].startDate.getDay());\n        const weekEnd = new Date(parsedData[parsedData.length - 1].startDate.getFullYear(), parsedData[parsedData.length - 1].startDate.getMonth(), parsedData[parsedData.length - 1].startDate.getDate() + 6);\n        const totalWeeks = Math.ceil((weekEnd - weekStart) / (1000 * 60 * 60 * 24 * 7));\n        this.totalWeeks = totalWeeks;\n        this.weekStart = weekStart;\n\n        // Crea il grafico utilizzando D3\n        const margin = { top: 20, right: 20, bottom: 30, left: 40 };\n        const width = 800 - margin.left - margin.right;\n        const height = 400 - margin.top - margin.bottom;\n\n        const svg = d3\n        .select(this.$refs.chartContainer)\n        .append(\"svg\")\n        .attr(\"width\", width + margin.left + margin.right)\n        .attr(\"height\", height + margin.top + margin.bottom);\n\n        const chart = svg.append(\"g\").attr(\"transform\", `translate(${margin.left},${margin.top})`);\n\n        // Funzione per aggiornare il grafico in base alla settimana selezionata\n        const updateChart = () => {\n        const currentWeekStart = new Date(this.weekStart.getFullYear(), this.weekStart.getMonth(), this.weekStart.getDate() + (this.currentWeekIndex * 7));\n        const currentWeekEnd = new Date(currentWeekStart.getFullYear(), currentWeekStart.getMonth(), currentWeekStart.getDate() + 6);\n        const currentWeekData = parsedData.filter((d) => {\n            return d.startDate >= currentWeekStart && d.startDate <= currentWeekEnd;\n        });\n\n        // Calcola il totale della differenza tra startDate e endDate per ogni giorno della settimana\n        const weekdays = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"]; \n        const totalTravelTime = parsedData.reduce((total, d) => total + d.travelTime, 0);\n        this.totalTravelTime = totalTravelTime;\n        const totalTravelTimes = weekdays.map((day) => {\n            const dayTravelTimes = currentWeekData.filter((d) => d.startDate.getDay() === weekdays.indexOf(day));\n            const totalTravelTime = d3.sum(dayTravelTimes, (d) => d.travelTime);\n            return { day, totalTravelTime };\n        });\n\n        // Rimuovi il vecchio grafico\n        svg.selectAll(\".bar\").remove();\n        svg.selectAll(\".x-axis\").remove();\n        svg.selectAll(\".y-axis\").remove();\n\n        // Scala per gli assi x e y\n        const x = d3.scaleBand().domain(weekdays).range([0, width]).padding(0.1);\n\n        const yTicks = d3.range(0, this.maxTravelTime + 600, 600); // Utilizza this.maxTravelTime come valore massimo per l'asse y\n        const y = d3\n            .scaleLinear()\n            .domain([0, this.maxTravelTime + 600])\n            .range([height, 0]);\n\n        // Creazione degli assi x e y\n        const xAxis = d3.axisBottom(x);\n        const yAxis = d3\n            .axisLeft(y)\n            .tickValues(yTicks)\n            .tickFormat((d) => {\n            const hours = Math.floor(d / 60); // Calcola le ore\n            return `${hours}`; // Formatta l'etichetta come \"hh:00\"\n            });\n\n        // Aggiungi gli assi al grafico\n        chart.append(\"g\").attr(\"class\", \"x-axis\").attr(\"transform\", `translate(0, ${height})`).call(xAxis);\n        chart.append(\"g\").attr(\"class\", \"y-axis\").call(yAxis);\n\n        // Crea le barre del grafico\n        chart\n            .selectAll(\".bar\")\n            .data(totalTravelTimes)\n            .enter()\n            .append(\"rect\")\n            .attr(\"class\", \"bar\")\n            .attr(\"x\", (d) => x(d.day))\n            .attr(\"y\", (d) => y(d.totalTravelTime))\n            .attr(\"width\", x.bandwidth())\n            .attr(\"height\", (d) => height - y(d.totalTravelTime));\n        };\n\n        // Calcola il valore massimo della durata del viaggio su tutte le settimane\n        const maxTravelTime = d3.max(parsedData, (d) => d.travelTime);\n        this.maxTravelTime = maxTravelTime;\n\n        // Aggiorna il grafico iniziale\n        updateChart();\n\n        // Aggiorna il grafico quando viene cambiata la settimana selezionata\n        this.$watch(\"currentWeekIndex\", () => {\n        updateChart();\n        });\n    });\n    },\n    formatWeekLabel(value) {\n    const currentWeekStart = new Date(this.weekStart.getFullYear(), this.weekStart.getMonth(), this.weekStart.getDate() + (value * 7));\n    const currentWeekEnd = new Date(currentWeekStart.getFullYear(), currentWeekStart.getMonth(), currentWeekStart.getDate() + 6);\n\n    const startDay = currentWeekStart.getDate();\n    const startMonth = new Intl.DateTimeFormat('en', { month: 'long' }).format(currentWeekStart);\n    const startYear = currentWeekStart.getFullYear();\n\n    const endDay = currentWeekEnd.getDate();\n    const endMonth = new Intl.DateTimeFormat('en', { month: 'long' }).format(currentWeekEnd);\n    const endYear = currentWeekEnd.getFullYear();\n\n    return `${startDay} ${startMonth} ${startYear} - ${endDay} ${endMonth} ${endYear}`;\n    },\n},\n};\n</script> "],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}