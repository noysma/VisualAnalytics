{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nconst d3 = require(\"d3\");\nfunction BuildingMap() {\n  let color = d3.scaleOrdinal(d3.schemeCategory10);\n  let selectedTypes = []; // Array vuoto per tenere traccia delle categorie selezionate dall'utente.\n\n  function me(selection) {\n    const buildingTypes = d3.groups(selection.datum().map(d => d.properties.buildingType), d => d).map(d => d[0]);\n    color.domain(buildingTypes);\n    const extent = {\n      type: \"GeometryCollection\",\n      geometries: selection.datum().map(d => d.geometry)\n    };\n    const projection = d3.geoIdentity().reflectY(true).fitSize([700, 700], extent);\n    const path = d3.geoPath().projection(projection);\n    selection.selectAll(\"path\").data(selection.datum()).join(\"path\").attr(\"d\", path).attr(\"fill\", d => color(d.properties.buildingType)).on(\"click\", function (d) {\n      const index = selectedTypes.indexOf(d.properties.buildingType);\n      if (index === -1) {\n        selectedTypes.push(d.properties.buildingType);\n      } else {\n        selectedTypes.splice(index, 1);\n      }\n      updateMap(); // Chiamo una funzione che aggiorna la mappa con le categorie selezionate.\n    }).attr(\"fill-opacity\", 0.2).classed(\"selected\", d => selectedTypes.includes(d.properties.buildingType)); // Aggiunge la classe \"selected\" agli elementi selezionati dall'utente.\n\n    function updateMap() {\n      // Seleziona gli elementi sulla mappa corrispondenti alle categorie di edifici selezionate\n      const selectedElements = selection.selectAll(\"path\").filter(d => selectedTypes.includes(d.properties.buildingType));\n      // Rimuovi tutte le selezioni precedenti\n      selection.selectAll(\"path.selected\").classed(\"selected\", false);\n      // Aggiungi la classe \"selected\" agli elementi selezionati\n      selectedElements.classed(\"selected\", true);\n    }\n  }\n  me.color = function (_) {\n    if (!arguments.length) return color;\n    color = _;\n    return me;\n  };\n  me.selectedTypes = function (_) {\n    if (!arguments.length) return selectedTypes;\n    selectedTypes = _;\n    return me;\n  };\n  return me;\n}\nfunction BuildingTypeLegend() {\n  let color = d3.scaleOrdinal(d3.schemeCategory10);\n  let selectedTypes = []; // Array vuoto per tenere traccia delle categorie selezionate dall'utente.\n\n  function me(selection) {\n    const legend = selection.append(\"g\").attr(\"transform\", \"translate(500, 20)\");\n    const filteredData = color.domain().filter(d => selectedTypes.includes(d)); // Filtra i dati per mostrare solo le categorie selezionate.\n    const legendItem = legend.selectAll(\"g\").data(filteredData).join(\"g\").attr(\"transform\", (d, i) => `translate(0, ${i * 20})`);\n    legendItem.append(\"rect\").attr(\"width\", 10).attr(\"height\", 10).attr(\"fill-opacity\", d => selectedTypes.includes(d) ? 1 : 0.2) // Imposta l'opacità in base alle categorie selezionate.\n    .attr(\"fill\", d => color(d)).on(\"click\", function (d) {\n      const index = selectedTypes.indexOf(d);\n      if (index === -1) {\n        selectedTypes.push(d);\n      } else {\n        selectedTypes.splice(index, 1);\n      }\n      updateLegend(); // Chiamo una funzione che aggiorna la legenda con le categorie selezionate.\n      updateMap(); // Chiamo una funzione che aggiorna la mappa con le categorie selezionate.\n    });\n\n    legendItem.append(\"text\").attr(\"x\", 15).attr(\"y\", 10).text(d => d);\n    function updateLegend() {\n      // Filtra i dati per mostrare solo le categorie selezionate.\n      const filteredData = color.domain().filter(d => selectedTypes.includes(d));\n      // Seleziona gli elementi della legenda corrispondenti alle categorie selezionate.\n      const selectedItems = legend.selectAll(\"rect\").data(filteredData, d => d);\n      // Aggiorna l'opacità degli elementi selezionati.\n      selectedItems.attr(\"fill-opacity\", 1);\n      // Rimuovi gli elementi della legenda che non sono più selezionati.\n      selectedItems.exit().attr(\"fill-opacity\", 0.2).remove();\n      // Aggiungi gli elementi della legenda che sono stati selezionati.\n      selectedItems.enter().append(\"rect\").attr(\"width\", 10).attr(\"height\", 10).attr(\"fill-opacity\", 1).attr(\"fill\", d => color(d)).merge(selectedItems).attr(\"fill-opacity\", 1);\n    }\n  }\n  me.color = function (_) {\n    if (!arguments.length) return color;\n    color = _;\n    return me;\n  };\n  me.selectedTypes = function (_) {\n    if (!arguments.length) return selectedTypes;\n    selectedTypes = _;\n    return me;\n  };\n  return me;\n}\nexport { BuildingMap, BuildingTypeLegend };","map":{"version":3,"names":["d3","require","BuildingMap","color","scaleOrdinal","schemeCategory10","selectedTypes","me","selection","buildingTypes","groups","datum","map","d","properties","buildingType","domain","extent","type","geometries","geometry","projection","geoIdentity","reflectY","fitSize","path","geoPath","selectAll","data","join","attr","on","index","indexOf","push","splice","updateMap","classed","includes","selectedElements","filter","_","arguments","length","BuildingTypeLegend","legend","append","filteredData","legendItem","i","updateLegend","text","selectedItems","exit","remove","enter","merge"],"sources":["/Users/camillachiruzzi/vastprof/VAST2022Vue/src/assets/BuildingMap.js"],"sourcesContent":["const d3 = require(\"d3\");\n\nfunction BuildingMap(){\n    let color = d3.scaleOrdinal(d3.schemeCategory10);\n    let selectedTypes = []; // Array vuoto per tenere traccia delle categorie selezionate dall'utente.\n\n    function me(selection){\n        const buildingTypes = d3.groups(selection.datum()\n            .map(d => d.properties.buildingType), d=>d).map(d => d[0]);\n        color.domain(buildingTypes);\n\n        const extent = {\n            type: \"GeometryCollection\",\n            geometries: selection.datum().map(d => d.geometry)\n        };\n\n        const projection = d3.geoIdentity().reflectY(true).fitSize([700, 700], extent);\n        const path = d3.geoPath().projection(projection);\n\n        selection.selectAll(\"path\")\n            .data(selection.datum())\n            .join(\"path\")\n            .attr(\"d\", path)\n            .attr(\"fill\", d => color(d.properties.buildingType))\n            .on(\"click\", function(d) {\n                const index = selectedTypes.indexOf(d.properties.buildingType);\n                if (index === -1) {\n                    selectedTypes.push(d.properties.buildingType);\n                } else {\n                    selectedTypes.splice(index, 1);\n                }\n                updateMap(); // Chiamo una funzione che aggiorna la mappa con le categorie selezionate.\n            })\n            .attr(\"fill-opacity\", 0.2)\n            .classed(\"selected\", d => selectedTypes.includes(d.properties.buildingType)); // Aggiunge la classe \"selected\" agli elementi selezionati dall'utente.\n\n        function updateMap() {\n            // Seleziona gli elementi sulla mappa corrispondenti alle categorie di edifici selezionate\n            const selectedElements = selection.selectAll(\"path\")\n                .filter(d => selectedTypes.includes(d.properties.buildingType));\n            // Rimuovi tutte le selezioni precedenti\n            selection.selectAll(\"path.selected\")\n                .classed(\"selected\", false);\n            // Aggiungi la classe \"selected\" agli elementi selezionati\n            selectedElements.classed(\"selected\", true);\n        }\n    }\n\n    me.color = function(_){\n        if (!arguments.length) return color;\n        color = _;\n        return me;\n    }\n\n    me.selectedTypes = function(_){\n        if (!arguments.length) return selectedTypes;\n        selectedTypes = _;\n        return me;\n    }\n\n    return me;\n}\n\nfunction BuildingTypeLegend(){\n    let color = d3.scaleOrdinal(d3.schemeCategory10);\n    let selectedTypes = []; // Array vuoto per tenere traccia delle categorie selezionate dall'utente.\n\n    function me(selection){\n        const legend = selection.append(\"g\")\n            .attr(\"transform\", \"translate(500, 20)\");\n\n        const filteredData = color.domain().filter(d => selectedTypes.includes(d)); // Filtra i dati per mostrare solo le categorie selezionate.\n        const legendItem = legend.selectAll(\"g\")\n            .data(filteredData)\n            .join(\"g\")\n            .attr(\"transform\", (d, i) => `translate(0, ${i*20})`);\n\n        legendItem.append(\"rect\")\n            .attr(\"width\", 10)\n            .attr(\"height\", 10)\n            .attr(\"fill-opacity\", d => selectedTypes.includes(d) ? 1 : 0.2) // Imposta l'opacità in base alle categorie selezionate.\n            .attr(\"fill\", d => color(d))\n            .on(\"click\", function(d) {\n                const index = selectedTypes.indexOf(d);\n                if (index === -1) {\n                    selectedTypes.push(d);\n                } else {\n                    selectedTypes.splice(index, 1);\n                }\n                updateLegend(); // Chiamo una funzione che aggiorna la legenda con le categorie selezionate.\n                updateMap(); // Chiamo una funzione che aggiorna la mappa con le categorie selezionate.\n            });\n\n        legendItem.append(\"text\")\n            .attr(\"x\", 15)\n            .attr(\"y\",10)\n            .text(d => d);\n\n        function updateLegend() {\n            // Filtra i dati per mostrare solo le categorie selezionate.\n            const filteredData = color.domain().filter(d => selectedTypes.includes(d));\n            // Seleziona gli elementi della legenda corrispondenti alle categorie selezionate.\n            const selectedItems = legend.selectAll(\"rect\")\n                .data(filteredData, d => d);\n            // Aggiorna l'opacità degli elementi selezionati.\n            selectedItems.attr(\"fill-opacity\", 1);\n            // Rimuovi gli elementi della legenda che non sono più selezionati.\n            selectedItems.exit().attr(\"fill-opacity\", 0.2).remove();\n            // Aggiungi gli elementi della legenda che sono stati selezionati.\n            selectedItems.enter()\n                .append(\"rect\")\n                .attr(\"width\", 10)\n                .attr(\"height\", 10)\n                .attr(\"fill-opacity\", 1)\n                .attr(\"fill\", d => color(d))\n                .merge(selectedItems)\n                .attr(\"fill-opacity\", 1);\n        }\n    }\n\n    me.color = function(_){\n        if (!arguments.length) return color;\n        color = _;\n        return me;\n    }\n\n    me.selectedTypes = function(_){\n        if (!arguments.length) return selectedTypes;\n        selectedTypes = _;\n        return me;\n    }\n\n    return me;\n}\n\nexport {\n    BuildingMap,\n    BuildingTypeLegend\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}