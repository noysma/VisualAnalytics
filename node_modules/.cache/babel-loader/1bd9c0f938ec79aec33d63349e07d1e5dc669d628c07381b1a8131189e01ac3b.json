{"ast":null,"code":"import { getSingleEndpoint } from \"../assets/apiConnector\";\n//   const d3 = require(\"d3\"); \n\nexport default {\n  data() {\n    return {\n      heatmapData: [],\n      participantStatusLogs: [] // Dati per la heatmap\n    };\n  },\n\n  mounted() {\n    this.initializeHeatmap();\n  },\n  methods: {\n    getParticipantStatusLogs() {\n      return getSingleEndpoint({\n        participantId: 1\n      }, 'ParticipantStatusLogs').then(response => {\n        this.participantStatusLogs = response.data.map(d => ({\n          type: \"Feature\",\n          properties: {\n            timestamp: d.timestamp,\n            currentMode: d.currentMode,\n            participantId: d.participantId\n          }\n        }));\n      }).catch(error => {\n        console.error('Error accessing data:', error);\n      });\n    }\n    //   initializeHeatmap() {\n    //     const discretizedTimestamps = this.discretizeTimestamps(this.participantStatusLogs);\n    //     const groupedData = this.groupDataByDay(this.participantStatusLogs);\n    //     this.heatmapData = this.createHeatmapData(discretizedTimestamps, groupedData);\n    //   },\n    //   discretizeTimestamps(data) {\n    //     const timestamps = data.map(item => item.properties.timestamp);\n    //     const sortedTimestamps = timestamps.sort((a, b) => a - b);\n\n    //     const startTimestamp = sortedTimestamps[0];\n    //     const endTimestamp = sortedTimestamps[sortedTimestamps.length - 1];\n    //     const interval = 3 * 60 * 60 * 1000; // Intervallo di 3 ore in millisecondi\n\n    //     const discretizedTimestamps = [];\n\n    //     for (let timestamp = startTimestamp; timestamp <= endTimestamp; timestamp += interval) {\n    //       discretizedTimestamps.push(timestamp);\n    //     }\n\n    //     return discretizedTimestamps;\n    //   },\n    //   groupDataByDay(data) {\n    //     const groupedData = {};\n    //     // Group the data by day\n    //     data.forEach(item => {\n    //       const date = this.getDateString(item.properties.timestamp);\n    //       if (!groupedData[date]) {\n    //         groupedData[date] = [];\n    //       }\n    //       groupedData[date].push(item);\n    //     });\n    //     return groupedData;\n    //   },\n    //   getDateString(timestamp) {\n    //     const dateObj = new Date(timestamp);\n    //     const year = dateObj.getFullYear();\n    //     const month = this.addLeadingZero(dateObj.getMonth() + 1);\n    //     const day = this.addLeadingZero(dateObj.getDate());\n    //     return `${year}-${month}-${day}`;\n    //   },\n    //   addLeadingZero(value) {\n    //     return value < 10 ? `0${value}` : value.toString();\n    //   },\n    //   createHeatmapData(timestamps, groupedData) {\n    //     const heatmapData = [];\n    //     for (const date in groupedData) {\n    //       const dayData = groupedData[date];\n    //       const rowData = [];\n    //       for (let i = 0; i < timestamps.length - 1; i++) {\n    //         const intervalStart = timestamps[i];\n    //         const intervalEnd = timestamps[i + 1];\n    //         const modeChange = this.checkModeChange(dayData, intervalStart, intervalEnd);\n    //         const color = modeChange ? this.getColor(dayData, intervalStart) : '';\n    //         rowData.push(color);\n    //       }\n    //       heatmapData.push(rowData);\n    //     }\n    //     return heatmapData;\n    //   },\n    //   checkModeChange(data, start, end) {\n    //     for (const item of data) {\n    //       if (item.properties.timestamp >= start && item.properties.timestamp < end) {\n    //         if (item.properties.currentMode !== data[0].properties.currentMode) {\n    //           return true;\n    //         }\n    //       }\n    //     }\n    //     return false;\n    //   },\n    //   getColor(data, timestamp) {\n    //     const uniqueModes = [...new Set(data.map(item => item.properties.currentMode))];\n    //     const colorScale = d3.scaleOrdinal()\n    //       .domain(uniqueModes)\n    //       .range(d3.schemeCategory10);\n\n    //     for (const item of data) {\n    //       if (item.properties.timestamp === timestamp) {\n    //         return colorScale(item.properties.currentMode);\n    //       }\n    //     }\n    //     return '';\n    //   },\n    //   getSquareClass(square) {\n    //     return square ? `square ${square}` : 'square';\n    //   },\n  }\n};","map":{"version":3,"names":["getSingleEndpoint","data","heatmapData","participantStatusLogs","mounted","initializeHeatmap","methods","getParticipantStatusLogs","participantId","then","response","map","d","type","properties","timestamp","currentMode","catch","error","console"],"sources":["src/components/Challenge3.vue"],"sourcesContent":["<!-- eslint-disable vue/multi-word-component-names -->\n\n<template>\n    <div>\n      <div class=\"heatmap-container\">\n        <div v-for=\"(row, index) in heatmapData\" :key=\"index\" class=\"heatmap-row\">\n          <div v-for=\"(square, colIndex) in row\" :key=\"colIndex\" :class=\"getSquareClass(square)\">\n            {{ square }}\n          </div>\n        </div>\n      </div>\n    </div>\n  </template>\n  \n  \n  <script>\n  import { getSingleEndpoint } from \"../assets/apiConnector\";\n//   const d3 = require(\"d3\"); \n  \n  export default {\n    data() {\n      return {\n        heatmapData: [],\n        participantStatusLogs: [], // Dati per la heatmap\n      };\n    },\n    mounted() {\n        this.initializeHeatmap();\n    },\n    methods: {\n      getParticipantStatusLogs() {\n        return getSingleEndpoint({ participantId: 1 }, 'ParticipantStatusLogs')\n          .then((response) => {\n            this.participantStatusLogs = response.data.map(d => ({\n              type: \"Feature\",\n              properties: {\n                timestamp: d.timestamp,\n                currentMode: d.currentMode,\n                participantId: d.participantId,\n              },\n            }));\n          })\n          .catch((error) => {\n            console.error('Error accessing data:', error);\n          });\n      },\n    //   initializeHeatmap() {\n    //     const discretizedTimestamps = this.discretizeTimestamps(this.participantStatusLogs);\n    //     const groupedData = this.groupDataByDay(this.participantStatusLogs);\n    //     this.heatmapData = this.createHeatmapData(discretizedTimestamps, groupedData);\n    //   },\n    //   discretizeTimestamps(data) {\n    //     const timestamps = data.map(item => item.properties.timestamp);\n    //     const sortedTimestamps = timestamps.sort((a, b) => a - b);\n  \n    //     const startTimestamp = sortedTimestamps[0];\n    //     const endTimestamp = sortedTimestamps[sortedTimestamps.length - 1];\n    //     const interval = 3 * 60 * 60 * 1000; // Intervallo di 3 ore in millisecondi\n  \n    //     const discretizedTimestamps = [];\n  \n    //     for (let timestamp = startTimestamp; timestamp <= endTimestamp; timestamp += interval) {\n    //       discretizedTimestamps.push(timestamp);\n    //     }\n  \n    //     return discretizedTimestamps;\n    //   },\n    //   groupDataByDay(data) {\n    //     const groupedData = {};\n    //     // Group the data by day\n    //     data.forEach(item => {\n    //       const date = this.getDateString(item.properties.timestamp);\n    //       if (!groupedData[date]) {\n    //         groupedData[date] = [];\n    //       }\n    //       groupedData[date].push(item);\n    //     });\n    //     return groupedData;\n    //   },\n    //   getDateString(timestamp) {\n    //     const dateObj = new Date(timestamp);\n    //     const year = dateObj.getFullYear();\n    //     const month = this.addLeadingZero(dateObj.getMonth() + 1);\n    //     const day = this.addLeadingZero(dateObj.getDate());\n    //     return `${year}-${month}-${day}`;\n    //   },\n    //   addLeadingZero(value) {\n    //     return value < 10 ? `0${value}` : value.toString();\n    //   },\n    //   createHeatmapData(timestamps, groupedData) {\n    //     const heatmapData = [];\n    //     for (const date in groupedData) {\n    //       const dayData = groupedData[date];\n    //       const rowData = [];\n    //       for (let i = 0; i < timestamps.length - 1; i++) {\n    //         const intervalStart = timestamps[i];\n    //         const intervalEnd = timestamps[i + 1];\n    //         const modeChange = this.checkModeChange(dayData, intervalStart, intervalEnd);\n    //         const color = modeChange ? this.getColor(dayData, intervalStart) : '';\n    //         rowData.push(color);\n    //       }\n    //       heatmapData.push(rowData);\n    //     }\n    //     return heatmapData;\n    //   },\n    //   checkModeChange(data, start, end) {\n    //     for (const item of data) {\n    //       if (item.properties.timestamp >= start && item.properties.timestamp < end) {\n    //         if (item.properties.currentMode !== data[0].properties.currentMode) {\n    //           return true;\n    //         }\n    //       }\n    //     }\n    //     return false;\n    //   },\n    //   getColor(data, timestamp) {\n    //     const uniqueModes = [...new Set(data.map(item => item.properties.currentMode))];\n    //     const colorScale = d3.scaleOrdinal()\n    //       .domain(uniqueModes)\n    //       .range(d3.schemeCategory10);\n  \n    //     for (const item of data) {\n    //       if (item.properties.timestamp === timestamp) {\n    //         return colorScale(item.properties.currentMode);\n    //       }\n    //     }\n    //     return '';\n    //   },\n    //   getSquareClass(square) {\n    //     return square ? `square ${square}` : 'square';\n    //   },\n    },\n  };\n\n  </script>\n  "],"mappings":"AAgBA,SAAAA,iBAAA;AACA;;AAEA;EACAC,KAAA;IACA;MACAC,WAAA;MACAC,qBAAA;IACA;EACA;;EACAC,QAAA;IACA,KAAAC,iBAAA;EACA;EACAC,OAAA;IACAC,yBAAA;MACA,OAAAP,iBAAA;QAAAQ,aAAA;MAAA,4BACAC,IAAA,CAAAC,QAAA;QACA,KAAAP,qBAAA,GAAAO,QAAA,CAAAT,IAAA,CAAAU,GAAA,CAAAC,CAAA;UACAC,IAAA;UACAC,UAAA;YACAC,SAAA,EAAAH,CAAA,CAAAG,SAAA;YACAC,WAAA,EAAAJ,CAAA,CAAAI,WAAA;YACAR,aAAA,EAAAI,CAAA,CAAAJ;UACA;QACA;MACA,GACAS,KAAA,CAAAC,KAAA;QACAC,OAAA,CAAAD,KAAA,0BAAAA,KAAA;MACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IAEA;IACA;IACA;;IAEA;;IAEA;IACA;IACA;;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;EACA;AACA"},"metadata":{},"sourceType":"module","externalDependencies":[]}