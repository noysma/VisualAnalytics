{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { getSingleEndpoint } from \"../assets/apiConnector\";\nconst d3 = require(\"d3\");\nexport default {\n  data() {\n    return {\n      participantId: 1,\n      // ID del partecipante per il quale vuoi selezionare i dati\n      participantStatusLogs: [],\n      // Array di dati ottenuti dall'API\n      heatmapData: [] // Dati per la heatmap\n    };\n  },\n\n  mounted() {\n    this.getParticipantStatusLogs().then(() => {\n      this.initializeHeatmap();\n    });\n  },\n  methods: {\n    getParticipantStatusLogs() {\n      return getSingleEndpoint({\n        participantId: this.participantId\n      }, 'ParticipantStatusLogs').then(response => {\n        this.participantStatusLogs = response.data.map(d => ({\n          type: \"Feature\",\n          properties: {\n            participantId: d.participantId,\n            timestamp: d.timestamp,\n            currentMode: d.currentMode\n          }\n        }));\n      }).catch(error => {\n        console.error('Error accessing data:', error);\n      });\n    },\n    initializeHeatmap() {\n      const discretizedTimestamps = this.discretizeTimestamps(this.participantStatusLogs);\n      const groupedData = this.groupDataByDay(this.participantStatusLogs);\n      this.heatmapData = this.createHeatmapData(discretizedTimestamps, groupedData);\n    },\n    //   discretizeTimestamps(data) {\n    //     const timestamps = data.map(item => item.properties.timestamp);\n    //     // Logic to discretize the timestamps into 3-hour intervals\n    //     // Return the array of discretized timestamps\n    //   },\n    groupDataByDay(data) {\n      const groupedData = {};\n      // Group the data by day\n      data.forEach(item => {\n        const date = this.getDateString(item.properties.timestamp);\n        if (!groupedData[date]) {\n          groupedData[date] = [];\n        }\n        groupedData[date].push(item);\n      });\n      return groupedData;\n    },\n    getDateString(timestamp) {\n      const dateObj = new Date(timestamp);\n      const year = dateObj.getFullYear();\n      const month = this.addLeadingZero(dateObj.getMonth() + 1);\n      const day = this.addLeadingZero(dateObj.getDate());\n      return `${year}-${month}-${day}`;\n    },\n    addLeadingZero(value) {\n      return value < 10 ? `0${value}` : value.toString();\n    },\n    createHeatmapData(timestamps, groupedData) {\n      const heatmapData = [];\n      for (const date in groupedData) {\n        const dayData = groupedData[date];\n        const rowData = [];\n        for (let i = 0; i < timestamps.length - 1; i++) {\n          const intervalStart = timestamps[i];\n          const intervalEnd = timestamps[i + 1];\n          const modeChange = this.checkModeChange(dayData, intervalStart, intervalEnd);\n          const color = modeChange ? this.getColor(dayData, intervalStart) : '';\n          rowData.push(color);\n        }\n        heatmapData.push(rowData);\n      }\n      return heatmapData;\n    },\n    checkModeChange(data, start, end) {\n      for (const item of data) {\n        if (item.properties.timestamp >= start && item.properties.timestamp < end) {\n          if (item.properties.currentMode !== data[0].properties.currentMode) {\n            return true;\n          }\n        }\n      }\n      return false;\n    },\n    getColor(data, timestamp) {\n      const uniqueModes = [...new Set(data.map(item => item.properties.currentMode))];\n      const colorScale = d3.scaleOrdinal().domain(uniqueModes).range(d3.schemeCategory10);\n      for (const item of data) {\n        if (item.properties.timestamp === timestamp) {\n          return colorScale(item.properties.currentMode);\n        }\n      }\n      return '';\n    },\n    getSquareClass(square) {\n      return square ? `square ${square}` : 'square';\n    }\n  }\n};","map":{"version":3,"names":["getSingleEndpoint","d3","require","data","participantId","participantStatusLogs","heatmapData","mounted","getParticipantStatusLogs","then","initializeHeatmap","methods","response","map","d","type","properties","timestamp","currentMode","catch","error","console","discretizedTimestamps","discretizeTimestamps","groupedData","groupDataByDay","createHeatmapData","forEach","item","date","getDateString","push","dateObj","Date","year","getFullYear","month","addLeadingZero","getMonth","day","getDate","value","toString","timestamps","dayData","rowData","i","length","intervalStart","intervalEnd","modeChange","checkModeChange","color","getColor","start","end","uniqueModes","Set","colorScale","scaleOrdinal","domain","range","schemeCategory10","getSquareClass","square"],"sources":["src/components/Challenge3.vue"],"sourcesContent":["<!-- eslint-disable vue/multi-word-component-names -->\n\n<template>\n    <div>\n      <div class=\"heatmap-container\">\n        <div v-for=\"(row, index) in heatmapData\" :key=\"index\" class=\"heatmap-row\">\n          <div v-for=\"(square, colIndex) in row\" :key=\"colIndex\" :class=\"getSquareClass(square)\">\n            <!-- Customize the content of the square here -->\n          </div>\n        </div>\n      </div>\n    </div>\n  </template>\n  \n  <script>\nimport { getSingleEndpoint } from \"../assets/apiConnector\";\nconst d3 = require(\"d3\"); \n\n  export default {\n    data() {\n      return {\n        participantId: 1, // ID del partecipante per il quale vuoi selezionare i dati\n        participantStatusLogs: [], // Array di dati ottenuti dall'API\n        heatmapData: [], // Dati per la heatmap\n      };\n    },\n    mounted() {\n      this.getParticipantStatusLogs().then(() => {\n        this.initializeHeatmap();\n      });\n    },\n    methods: {\n      getParticipantStatusLogs() {\n        return getSingleEndpoint({ participantId: this.participantId }, 'ParticipantStatusLogs')\n          .then((response) => {\n            this.participantStatusLogs = response.data.map(d => ({\n              type: \"Feature\",\n              properties: {\n                participantId: d.participantId,\n                timestamp: d.timestamp,\n                currentMode: d.currentMode,\n              },\n            }));\n          })\n          .catch((error) => {\n            console.error('Error accessing data:', error);\n          });\n      },\n      initializeHeatmap() {\n        const discretizedTimestamps = this.discretizeTimestamps(this.participantStatusLogs);\n        const groupedData = this.groupDataByDay(this.participantStatusLogs);\n        this.heatmapData = this.createHeatmapData(discretizedTimestamps, groupedData);\n      },\n    //   discretizeTimestamps(data) {\n    //     const timestamps = data.map(item => item.properties.timestamp);\n    //     // Logic to discretize the timestamps into 3-hour intervals\n    //     // Return the array of discretized timestamps\n    //   },\n      groupDataByDay(data) {\n        const groupedData = {};\n        // Group the data by day\n        data.forEach(item => {\n          const date = this.getDateString(item.properties.timestamp);\n          if (!groupedData[date]) {\n            groupedData[date] = [];\n          }\n          groupedData[date].push(item);\n        });\n        return groupedData;\n      },\n      getDateString(timestamp) {\n        const dateObj = new Date(timestamp);\n        const year = dateObj.getFullYear();\n        const month = this.addLeadingZero(dateObj.getMonth() + 1);\n        const day = this.addLeadingZero(dateObj.getDate());\n        return `${year}-${month}-${day}`;\n      },\n      addLeadingZero(value) {\n        return value < 10 ? `0${value}` : value.toString();\n      },\n      createHeatmapData(timestamps, groupedData) {\n        const heatmapData = [];\n        for (const date in groupedData) {\n          const dayData = groupedData[date];\n          const rowData = [];\n          for (let i = 0; i < timestamps.length - 1; i++) {\n            const intervalStart = timestamps[i];\n            const intervalEnd = timestamps[i + 1];\n            const modeChange = this.checkModeChange(dayData, intervalStart, intervalEnd);\n            const color = modeChange ? this.getColor(dayData, intervalStart) : '';\n            rowData.push(color);\n          }\n          heatmapData.push(rowData);\n        }\n        return heatmapData;\n      },\n      checkModeChange(data, start, end) {\n        for (const item of data) {\n          if (item.properties.timestamp >= start && item.properties.timestamp < end) {\n            if (item.properties.currentMode !== data[0].properties.currentMode) {\n              return true;\n            }\n          }\n        }\n        return false;\n      },\n      getColor(data, timestamp) {\n        const uniqueModes = [...new Set(data.map(item => item.properties.currentMode))];\n        const colorScale = d3.scaleOrdinal()\n          .domain(uniqueModes)\n          .range(d3.schemeCategory10);\n  \n        for (const item of data) {\n          if (item.properties.timestamp === timestamp) {\n            return colorScale(item.properties.currentMode);\n          }\n        }\n        return '';\n      },\n      getSquareClass(square) {\n        return square ? `square ${square}` : 'square';\n      },\n    },\n  };\n  </script>\n  "],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}